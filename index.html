<!-- CÃ³digo JS para generar imÃ¡genes de cartas (Canvas) -->
<script>
// Generador de imÃ¡genes de cartas (Canvas -> dataURL)
function generateCardImage(name, subtitle = '', type = 'tarot', opts = {}) {
  // TamaÃ±o pensado para mobile: 600x1000 (proporciÃ³n tarjeta)
  const w = opts.width || 600;
  const h = opts.height || 1000;
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d');

  // Helper: gradient aurora (segÃºn tipo podemos variar colores)
  const grad = ctx.createLinearGradient(0,0,w,h);
  if(type === 'angels') {
    grad.addColorStop(0, '#2b4865'); // azul oscuro
    grad.addColorStop(0.5, '#0f9b8e'); // aqua
    grad.addColorStop(1, '#88c3ff'); // celeste
  } else {
    grad.addColorStop(0, '#0f0c29');
    grad.addColorStop(0.4, '#302b63');
    grad.addColorStop(1, '#24243e');
  }
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,w,h);

  // Soft aurora overlay radial
  const rg = ctx.createRadialGradient(w*0.2, h*0.2, 50, w*0.2, h*0.2, h*0.9);
  rg.addColorStop(0, 'rgba(138,108,255,0.12)');
  rg.addColorStop(0.6, 'rgba(110,198,217,0.06)');
  rg.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = rg;
  ctx.fillRect(0,0,w,h);

  // Card inner rectangle (slightly inset)
  const pad = Math.round(w*0.06);
  const rx = pad, ry = pad, rw = w - pad*2, rh = h - pad*2;
  // rounded rect background (dark glass)
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  roundRect(ctx, rx, ry, rw, rh, 24, true, false);

  // decorative frame
  drawFrame(ctx, rx, ry, rw, rh);

  // symbol area (large central)
  const symY = ry + Math.round(rh*0.09);
  const symH = Math.round(rh*0.56);
  drawSymbol(ctx, w/2, symY + symH/2, Math.round(Math.min(w,rh)*0.18), type, opts.symbol);

  // Title
  ctx.fillStyle = '#e6f9ff';
  ctx.textAlign = 'center';
  ctx.font = `bold ${Math.round(w*0.06)}px Inter, system-ui, sans-serif`;
  ctx.fillText(name, w/2, symY + symH + Math.round(w*0.06));

  // Subtitle / breve
  if(subtitle){
    ctx.fillStyle = 'rgba(223,248,255,0.9)';
    ctx.font = `${Math.round(w*0.036)}px Inter, system-ui, sans-serif`;
    // wrap text
    wrapText(ctx, subtitle, w/2, symY + symH + Math.round(w*0.06) + 28, Math.round(w*0.8), Math.round(w*0.042));
  }

  // small footer credit
  ctx.fillStyle = 'rgba(191,239,253,0.8)';
  ctx.font = `${Math.round(w*0.03)}px Inter, system-ui, sans-serif`;
  ctx.fillText('CorAlma â€” OrÃ¡culo', w/2, h - pad + 6);

  // Invert rotated preview: If inverted, rotate the canvas content 180Â° onto a new canvas
  if(opts.inverted){
    const temp = document.createElement('canvas');
    temp.width = w; temp.height = h;
    const tctx = temp.getContext('2d');
    tctx.translate(w/2, h/2);
    tctx.rotate(Math.PI); // 180 deg
    tctx.translate(-w/2, -h/2);
    tctx.drawImage(canvas, 0, 0);
    return temp.toDataURL('image/png');
  }

  return canvas.toDataURL('image/png');

  // --- Utility functions inside ---
  function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
    if (typeof stroke === 'undefined') stroke = true;
    if (typeof radius === 'undefined') radius = 5;
    if (typeof radius === 'number') {
      radius = {tl: radius, tr: radius, br: radius, bl: radius};
    } else {
      var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
      for (var side in defaultRadius) {
        radius[side] = radius[side] || defaultRadius[side];
      }
    }
    ctx.beginPath();
    ctx.moveTo(x + radius.tl, y);
    ctx.lineTo(x + width - radius.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    ctx.lineTo(x + width, y + height - radius.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
    ctx.lineTo(x + radius.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
    ctx.lineTo(x, y + radius.tl);
    ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) {
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.stroke();
    }
  }
  function drawFrame(ctx, x, y, w, h){
    // soft gold frame
    ctx.save();
    ctx.lineWidth = Math.max(4, Math.round(w*0.01));
    const grad = ctx.createLinearGradient(x, y, x+w, y+h);
    grad.addColorStop(0, 'rgba(255,220,130,0.95)');
    grad.addColorStop(0.5, 'rgba(255,255,255,0.85)');
    grad.addColorStop(1, 'rgba(255,200,100,0.9)');
    ctx.strokeStyle = grad;
    // outer rounded rect stroke
    roundRect(ctx, x-6, y-6, w+12, h+12, 28, false, true);
    ctx.restore();
  }
  function drawSymbol(ctx, cx, cy, radius, type, symbol){
    ctx.save();
    // subtle halo
    const halo = ctx.createRadialGradient(cx,cy, radius*0.2, cx,cy, radius*1.2);
    halo.addColorStop(0, 'rgba(255,255,255,0.12)');
    halo.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = halo;
    ctx.beginPath();
    ctx.arc(cx, cy, radius*1.2, 0, Math.PI*2);
    ctx.fill();

    // central symbol: emoji fallback
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${Math.round(radius*1.2)}px serif`;
    let sym = symbol || (type === 'angels' ? 'ðŸ‘¼' : 'â˜…');
    ctx.fillText(sym, cx, cy + (type === 'angels' ? -6 : 0));

    ctx.restore();
  }
  function wrapText(ctx, text, x, y, maxWidth, lineHeight) {